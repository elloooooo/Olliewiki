== 寻找最大字串 ==
=== 要求 ===
从一个数组中寻找和最大的一个子串
=== 思路 ===
寻找一个长度为$n$的序列$A[0]-A[n]$的最大字串，想象，如果去掉序列最后一个元素，剩下$n-1$项序列$A[0]-A[n-1]$的最大字串并不一定是元序列的最大子串的一部分，所以不能通过这样的方法将原问题分解为规模更小的子问题。

最大子串一定是以某一个元素结尾，所以考察以所有元素结尾的最大子串的值，其中最大的就是整个序列的最大子串。
基于这个思路，相当于将原问题分解为查找以每个元素结尾的最大子串一组子问题。

这组子问题之间是有关联的，如知道以$A[n-1]$结尾的最大子串，则可以在常数时间内，获得以$A[n]$结尾的最大子串。
所以$A[n-1]$结尾的最大子串可以是为以$A[n]$结尾的最大子串的一个子问题。

利用自底向上的方式，先求子问题的解，然后逐步求解所有子问题的解。

=== 代码 ===
{{{class="brush:java; toolbar:false"
	/**
	 * 该方法使用动态规划的思想
	 * 原问题分解为寻找以每一个数为结尾的最大子串问题
	 * 而这些子问题之间有相互关联
	 * 知道A[n-1]为结尾的最大子串后，就可以在常熟时间内知道A[n]结尾的最大字串
	 * 最终取最大子串和最大的一个即可
	 * @param data
	 * @return
	 */
	public int[] findMaxString2(int[] data) {
		int[] res = new int [3];//存放结果：最大和，启始元素下标，结束元素下标
		int sum = 0;//存放以某一元素为结尾的最大字串的和值
		int max = -9999;//最大和的最大子串
		int from = 0;//起始元素下标
		int to = 0;//结束元素下标
		for (int i = 0; i < data.length; i++) {
			//每一次循环后sum为data[i]为结尾的最大子串和
			if (data[i] < sum + data[i]) {
				sum += data[i];
			} else {
				sum = data[i];
				from = i;
			}
			if(max<sum){
				max=sum;
				to = i;
			}
		}
		res[0] = from;
		res[1] = to;
		res[2] = max;
		return res;
	}

}}}

=== 算法分析 ===
利用此算法，可将时间复杂度降为$O(n)$,优于利用分治算法的$\Theta(n \lg n )$
