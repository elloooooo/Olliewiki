= 散列表 =
== 直接寻址表 ==
直接寻址表的下标作为关键字，关键字直接对应直接寻址表中的一个槽(slot)，缺点就是当关键字的全域很大时，可能需要存储一个很大的寻址表！实际存储的关键字可能比全域中小很多，这样会造成很多浪费!
== 散列表 ==
具有关键字`k`的元素放在`h(k)`个槽中,`h(k)`即为散列函数

*因为全域始终大于槽数，所以冲突不可避免* 

解决冲突的办法：
# *链接法* ： 将散列到同一个槽中的元素存储到链表中
# *开放寻址法* ：所有元素存在散列表中，所有元素要么包含动态集合中的一个元素，要么包含NIL，散列表会被填满而无法继续插入新值。由于不用指针，而是计算出存取的槽列，节省空间

定理:: 在简单均匀散列下，用链接法解决的冲突的散列表，依次成功或不成功的查找平均时间为$\Theta(1+\alpha)$

== 散列函数 ==
好的散列函数的特点
# (近似)满足简单均匀散列的假设，即每个关键字可以被等可能的散列到m个槽位上
# 相近的符号散列到相同槽位的可能性最小化
# 应该独立于数据可能存在的任何模式(如“除法散列法”)
# 甚至可以满足比简单均匀散列更强的性质，如将相近的关键字散列为截然不同的散列值（如“全域散列”）

=== 除法散列法 ===
*散列函数* $h(k)= k mod m $

将关键字k映射到m个槽中，m的选择不应该是2的幂，一个不太接近2的素数是比较好选择

=== 乘法散列法 ===
 *散列函数* $h(k) = \lfloor m(kA mod 1)\rfloor $

将关键字乘以常数A（0<A<1）提取小数部分，然后乘以m，向下取整

=== 全域散列法 ===
在执行开始时，就从一组函数中，随机的选择一个散列函数。算法在每一次执行中都会不同，以确保对于任何输入，算法的平均性能。
