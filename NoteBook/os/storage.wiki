= 存储器管理 =
== 页面置换算法 ==
=== 最佳置换算法 ===
未来最长时间不会被访问的页面被淘汰

但是由于实际上无法预测那些页面是未来最久不会访问的页面，所以该算法只是理论上的一种算法
=== 先进先出置换算法（FIFO） ===
选择内存中停留最久的页面淘汰

该算法与进程实际运行的规律并不相符，因为在进程中有些经常被访问的页面，如全局变量，常用函数等，还是会被淘汰

=== 最近最久未用置换算法（LRU） ===
选择最近，最久未被使用的页面淘汰

该算法不是如 *最佳置换算法* 一样，向后看，而是向前看的算法，即根据页面之前的访问去判断是否应该将其淘汰，而实际上，页面之前的使用情况与以后的使用情况是没有必然联系的。

需要额外的硬件支持
    - 寄存器，为每一个内存中的页面配置一个移位寄存器，记录页面的使用情况
    - 栈，每当一个页面被访问，就将这个页面至于栈顶
=== Clock置换算法 ===
==== 简单的Clock算法（最近未用算法（NRU）） ====
为每一位设置一个访问位，将内存中的页通过链接指针连成循环队列。当某页被访问，访问位置1。

置换算法在淘汰页面时，只检查访问位，如果为1，则将其置0，检查下一个页。

==== 改进的Clock算法 ====
在淘汰页面选择时，再加入一个置换低价作为考虑因素。即既要是未使用过的页面，同时也是未被修改过的页面，作为首选置换对象；

淘汰的优先级

| 1类 | 未访问 | 未修改 |
| 2类 | 未访问 | 已修改 |
| 3类 | 访问过 | 未修改 |
| 4类 | 访问过 | 已修改 |

=== 最少使用置换算法（LFU） ===
=== 页面缓冲算法（PBA） ===

