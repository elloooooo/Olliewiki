= JVM =
== 内存结构 ==
=== 堆 ===
==== 存放对象 ====
- 年轻代
  - eden
  - survive 1, 2
- 栈上的数据和静态区的对象作为root链

- 老年代
	- 大对象直接进入老年代
	- 年龄超过阈值的对象进入老年代
	 
==== 内存回收方式 ====
- 标记清除: 标记前要冻结状态
- 标记整理清除: 会卡顿，但是吞吐量大（常用于老年代）
- 复制：在survive区之间复制，速度比较快，常用于年轻代，适用于朝生夕死的小对象
- CMS并行收集器
	- 遍历root链时不锁前台线程
	- 标记一段时间之后，STW，检查root链，然后重新遍历一下已经标记的对象集合
	- 标记清除，没有整理
	- 开始运行时还可以运行前台线程，所以需要提早开始运行，否则可能OOM
	- 低延时，追求响应速度

- G1收集器
	- 将JVM申请的内存分为若干个块，块之间不一定相连
	- 在young代保存一份root链的，对老年代的对象进行分块
	- 对每一块内存空间进行分块复制清除算法
	
=== 栈 ===
=== 方法区 ===
存放字节码

=== Class ===
==== classloader ====
装载 链接 初始化
Bootstrap Extension Application

同级别的classloader加载的同一份字节码存在两份

孩子级别的classloader加载的类，父级别的线程是看不到的，
而父亲级别的线程加载的类，子线程是可以看到的，
因为父亲级别的classloader加载的类，其字节码的引用会在子级别中也有
