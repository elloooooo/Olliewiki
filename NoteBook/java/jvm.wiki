= JVM =
== 内存结构 ==
=== 堆 ===
存放对象
- 年轻代
  - eden
  - survive 1, 2
- 栈上的数据和静态区的对象作为root链

- 老年代
	- 大对象直接进入老年代
	- 岁数超过阈值进入老年代
- 标记清除
标记要冻结状态
- 标记整理清除 会卡顿，但是吞吐量达 常用于老年代 
- 复制 在survive之间复制 速度比较快 常用语年轻代 适用于朝生夕死的小对象
- CMS并行收集器
	- 遍历root链时不锁前台线程
	- 标记一段时间之后，STW，检查root链，然后重新遍历一下已经标记的对象集合
	- 标记清除，没有整理
	- 开始运行时还可以运行前台线程，所以需要提早开始运行，否则可能OOM
	- 低延时，追求响应速度

- G1收集器
	- 将JVM申请的内存分为若干个块，块之间不一定相连
	- 在young代保存一份root链的，对对老年代的对象进行分块
	- 对每一块内存空间进行分块复制清除算法
=== 栈 ===
=== 方法区 ===
存放字节码

=== Class ===
==== classloader ====
装载 链接 初始化
Bootstrap Extension Application

同级别的classloader加载的同一份字节码存在两份

孩子级别的classloader加载的类，父级别的线程是看不到的，
而父亲级别的线程加载的类，子线程是可以看到的，
因为父亲级别的classloader加载的类，其字节码的引用会在子级别中也有
